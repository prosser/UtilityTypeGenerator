namespace UtilityTypeGenerator;

using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

[Generator]
public sealed class UtilityTypeSourceGenerator : ISourceGenerator
{
    private const string AttributeSource = """
namespace UtilityTypeGenerator
{
    using System;

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
    internal class UtilityTypeAttribute(string selector) : Attribute
    {
        public string Selector { get; } = selector;
    }
}
""";

    public void Execute(GeneratorExecutionContext context)
    {
        // always add the attribute source. This is a semi-magical incantation that makes attributes on the generator work.
        context.AddSource("UtilityTypeAttribute.g.cs", AttributeSource);

        if (context.SyntaxReceiver is not UtilityTypeSyntaxReceiver receiver ||
            receiver.Received.Count == 0)
        {
            return;
        }

        StringBuilder sb = new StringBuilder()
            .AppendLine("// <auto-generated />")
            .Append("// generated at ").AppendLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"))
            .AppendLine("#nullable enable")
            .AppendLine();

        string? baseName = null;
        foreach ((TypeDeclarationSyntax typeSyntax, AttributeSyntax attribute) in receiver.Received)
        {
            string typeName = typeSyntax.Identifier.Text;
            if (string.IsNullOrEmpty(typeName))
            {
                continue;
            }

            // read the UtilityTypeAttribute from the class to augment
            if (attribute
                    .DescendantNodes()
                    .OfType<LiteralExpressionSyntax>()
                    .FirstOrDefault()
                    ?.Token.ValueText is not string selectorSyntax)
            {
                continue;
            }

            string[] usingNamespaces = [];
            if (typeSyntax.Ancestors().OfType<BaseNamespaceDeclarationSyntax>().FirstOrDefault()
                is BaseNamespaceDeclarationSyntax containingNamespace)
            {
                // get the "using namespaces" for the block where the attribute is defined
                string[] nsArray =
                    [
                        containingNamespace.Name?.ToFullString() ?? "",
                        .. containingNamespace.Usings
                        .Select(usingDirective => usingDirective.Name?.ToFullString() ?? "")
                    ];

                // remove empty strings and duplicates
                usingNamespaces = nsArray.Where(x => x.Length > 0).Distinct().ToArray();
            }

            try
            {
                // the accessibility of the output type is the same as the accessibility of the class to augment
                Accessibility accessibility = GetAccessibility(typeSyntax.Modifiers
                    .Select(modifier => modifier.Kind())
                    .Where(kind => kind is SyntaxKind.PublicKeyword or SyntaxKind.ProtectedKeyword or SyntaxKind.PrivateKeyword or SyntaxKind.InternalKeyword)
                    .ToArray());

                UtilityTypeSelector? selector = UtilityTypeParser.Parse(usingNamespaces, accessibility, context.Compilation, selectorSyntax);
                if (selector is null)
                {
                    context.ReportDiagnostic(Diagnostic.Create(Diagnostics.InvalidSelector, attribute.GetLocation(), selectorSyntax));
                    continue;
                }

                // get the namespace for the class
                string? @namespace = context.Compilation.GetSemanticModel(typeSyntax.SyntaxTree).GetDeclaredSymbol(typeSyntax)?.ContainingNamespace?.ToString();

                sb = sb.AppendLine(UtilityTypeCSharpGenerator.Generate(context.Compilation, selector, typeSyntax.Kind(), typeName, @namespace));
                baseName = Path.GetFileNameWithoutExtension(typeSyntax.SyntaxTree.FilePath);
            }
            catch (ArgumentException ex)
            {
                context.ReportDiagnostic(Diagnostic.Create(Diagnostics.InvalidPropertyName, attribute.GetLocation(), selectorSyntax, ex.Message));
            }
            catch (FormatException ex)
            {
                context.ReportDiagnostic(Diagnostic.Create(Diagnostics.InvalidSelector, attribute.GetLocation(), selectorSyntax, ex.Message));
            }
            catch (TypeLoadException ex)
            {
                context.ReportDiagnostic(Diagnostic.Create(Diagnostics.TypeError, attribute.GetLocation(), selectorSyntax, ex.Message));
            }
            catch (InvalidOperationException ex)
            {
                context.ReportDiagnostic(Diagnostic.Create(Diagnostics.TypeError, attribute.GetLocation(), selectorSyntax, ex.Message));
            }
            catch (Exception ex)
            {
                context.ReportDiagnostic(Diagnostic.Create(Diagnostics.UnknownError, attribute.GetLocation(), selectorSyntax, ex.ToString()));
            }
        }

        // if baseName was assigned, then we have at least one class to augment
        if (baseName is not null)
        {
            // get the file name containing the class to augment
            context.AddSource($"{baseName}.g.cs", sb.ToString());
        }
    }

    private Accessibility GetAccessibility(SyntaxKind[] kinds)
    {
        return kinds.Length == 0
            ? Accessibility.Internal
            : kinds.Length > 1
            ? kinds[0] switch
            {
                SyntaxKind.PublicKeyword => Accessibility.Public,
                SyntaxKind.ProtectedKeyword => kinds[1] switch
                {
                    SyntaxKind.InternalKeyword => Accessibility.ProtectedAndInternal,
                    _ => Accessibility.Public
                },
                SyntaxKind.PrivateKeyword => Accessibility.Private,
                _ => Accessibility.Internal,
            }
            : kinds[0] switch
            {
                SyntaxKind.PublicKeyword => Accessibility.Public,
                SyntaxKind.ProtectedKeyword => Accessibility.Protected,
                SyntaxKind.PrivateKeyword => Accessibility.Private,
                SyntaxKind.InternalKeyword => Accessibility.Internal,
                _ => Accessibility.Internal
            };
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new UtilityTypeSyntaxReceiver());
    }
}